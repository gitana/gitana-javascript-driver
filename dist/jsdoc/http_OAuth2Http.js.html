<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>Cloud CMS JavaScript Driver Source: http/OAuth2Http.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.cerulean.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top ">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">Cloud CMS JavaScript Driver</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="Gitana.html">Gitana</a></li><li><a href="Gitana.AbstractApplicationObject.html">Gitana.AbstractApplicationObject</a></li><li><a href="Gitana.AbstractClusterObject.html">Gitana.AbstractClusterObject</a></li><li><a href="Gitana.AbstractDirectoryObject.html">Gitana.AbstractDirectoryObject</a></li><li><a href="Gitana.AbstractDomainObject.html">Gitana.AbstractDomainObject</a></li><li><a href="Gitana.AbstractMap.html">Gitana.AbstractMap</a></li><li><a href="Gitana.AbstractNode.html">Gitana.AbstractNode</a></li><li><a href="Gitana.AbstractObject.html">Gitana.AbstractObject</a></li><li><a href="Gitana.AbstractPersistable.html">Gitana.AbstractPersistable</a></li><li><a href="Gitana.AbstractPlatformDataStore.html">Gitana.AbstractPlatformDataStore</a></li><li><a href="Gitana.AbstractPlatformObject.html">Gitana.AbstractPlatformObject</a></li><li><a href="Gitana.AbstractPlatformObjectMap.html">Gitana.AbstractPlatformObjectMap</a></li><li><a href="Gitana.AbstractRegistrarObject.html">Gitana.AbstractRegistrarObject</a></li><li><a href="Gitana.AbstractReportableWarehouseObject.html">Gitana.AbstractReportableWarehouseObject</a></li><li><a href="Gitana.AbstractRepositoryObject.html">Gitana.AbstractRepositoryObject</a></li><li><a href="Gitana.AbstractSelfableACLObject.html">Gitana.AbstractSelfableACLObject</a></li><li><a href="Gitana.AbstractSelfableObject.html">Gitana.AbstractSelfableObject</a></li><li><a href="Gitana.AbstractVaultObject.html">Gitana.AbstractVaultObject</a></li><li><a href="Gitana.AbstractWarehouseObject.html">Gitana.AbstractWarehouseObject</a></li><li><a href="Gitana.AbstractWarehouseObjectMap.html">Gitana.AbstractWarehouseObjectMap</a></li><li><a href="Gitana.AbstractWebHostObject.html">Gitana.AbstractWebHostObject</a></li><li><a href="Gitana.Activity.html">Gitana.Activity</a></li><li><a href="Gitana.ActivityMap.html">Gitana.ActivityMap</a></li><li><a href="Gitana.AppHelper.html">Gitana.AppHelper</a></li><li><a href="Gitana.Application.html">Gitana.Application</a></li><li><a href="Gitana.ApplicationMap.html">Gitana.ApplicationMap</a></li><li><a href="Gitana.Archive.html">Gitana.Archive</a></li><li><a href="Gitana.ArchiveMap.html">Gitana.ArchiveMap</a></li><li><a href="Gitana.Association.html">Gitana.Association</a></li><li><a href="Gitana.AuditRecord.html">Gitana.AuditRecord</a></li><li><a href="Gitana.AuditRecordMap.html">Gitana.AuditRecordMap</a></li><li><a href="Gitana.AuthenticationGrant.html">Gitana.AuthenticationGrant</a></li><li><a href="Gitana.AuthenticationGrantMap.html">Gitana.AuthenticationGrantMap</a></li><li><a href="Gitana.AuthInfo.html">Gitana.AuthInfo</a></li><li><a href="Gitana.AutoClientMapping.html">Gitana.AutoClientMapping</a></li><li><a href="Gitana.AutoClientMappingMap.html">Gitana.AutoClientMappingMap</a></li><li><a href="Gitana.BillingProviderConfiguration.html">Gitana.BillingProviderConfiguration</a></li><li><a href="Gitana.BillingProviderConfigurationMap.html">Gitana.BillingProviderConfigurationMap</a></li><li><a href="Gitana.BinaryAttachment.html">Gitana.BinaryAttachment</a></li><li><a href="Gitana.Branch.html">Gitana.Branch</a></li><li><a href="Gitana.BranchMap.html">Gitana.BranchMap</a></li><li><a href="Gitana.Chainable.html">Gitana.Chainable</a></li><li><a href="Gitana.Changeset.html">Gitana.Changeset</a></li><li><a href="Gitana.ChangesetMap.html">Gitana.ChangesetMap</a></li><li><a href="Gitana.Client.html">Gitana.Client</a></li><li><a href="Gitana.ClientMap.html">Gitana.ClientMap</a></li><li><a href="Gitana.Cluster.html">Gitana.Cluster</a></li><li><a href="Gitana.Connection.html">Gitana.Connection</a></li><li><a href="Gitana.ConnectionMap.html">Gitana.ConnectionMap</a></li><li><a href="Gitana.ContainedDataStore.html">Gitana.ContainedDataStore</a></li><li><a href="Gitana.Context.html">Gitana.Context</a></li><li><a href="Gitana.ConversionTrigger.html">Gitana.ConversionTrigger</a></li><li><a href="Gitana.ConversionTriggerMap.html">Gitana.ConversionTriggerMap</a></li><li><a href="Gitana.CopyJob.html">Gitana.CopyJob</a></li><li><a href="Gitana.DataStore.html">Gitana.DataStore</a></li><li><a href="Gitana.Definition.html">Gitana.Definition</a></li><li><a href="Gitana.Deletion.html">Gitana.Deletion</a></li><li><a href="Gitana.DeletionMap.html">Gitana.DeletionMap</a></li><li><a href="Gitana.DeployedApplication.html">Gitana.DeployedApplication</a></li><li><a href="Gitana.DeployedApplicationMap.html">Gitana.DeployedApplicationMap</a></li><li><a href="Gitana.DeploymentPackage.html">Gitana.DeploymentPackage</a></li><li><a href="Gitana.DeploymentPackageMap.html">Gitana.DeploymentPackageMap</a></li><li><a href="Gitana.DeploymentReceiver.html">Gitana.DeploymentReceiver</a></li><li><a href="Gitana.DeploymentReceiverMap.html">Gitana.DeploymentReceiverMap</a></li><li><a href="Gitana.DeploymentStrategy.html">Gitana.DeploymentStrategy</a></li><li><a href="Gitana.DeploymentStrategyMap.html">Gitana.DeploymentStrategyMap</a></li><li><a href="Gitana.DeploymentTarget.html">Gitana.DeploymentTarget</a></li><li><a href="Gitana.DeploymentTargetMap.html">Gitana.DeploymentTargetMap</a></li><li><a href="Gitana.Descriptor.html">Gitana.Descriptor</a></li><li><a href="Gitana.DescriptorMap.html">Gitana.DescriptorMap</a></li><li><a href="Gitana.Directory.html">Gitana.Directory</a></li><li><a href="Gitana.DirectoryMap.html">Gitana.DirectoryMap</a></li><li><a href="Gitana.Domain.html">Gitana.Domain</a></li><li><a href="Gitana.DomainMap.html">Gitana.DomainMap</a></li><li><a href="Gitana.DomainPrincipal.html">Gitana.DomainPrincipal</a></li><li><a href="Gitana.Email.html">Gitana.Email</a></li><li><a href="Gitana.EmailMap.html">Gitana.EmailMap</a></li><li><a href="Gitana.EmailProvider.html">Gitana.EmailProvider</a></li><li><a href="Gitana.EmailProviderMap.html">Gitana.EmailProviderMap</a></li><li><a href="Gitana.Form.html">Gitana.Form</a></li><li><a href="Gitana.HasFormAssociation.html">Gitana.HasFormAssociation</a></li><li><a href="Gitana.HasTranslationAssociation.html">Gitana.HasTranslationAssociation</a></li><li><a href="Gitana.Http.html">Gitana.Http</a></li><li><a href="Gitana.Identity.html">Gitana.Identity</a></li><li><a href="Gitana.IdentityMap.html">Gitana.IdentityMap</a></li><li><a href="Gitana.Interaction.html">Gitana.Interaction</a></li><li><a href="Gitana.InteractionApplication.html">Gitana.InteractionApplication</a></li><li><a href="Gitana.InteractionApplicationMap.html">Gitana.InteractionApplicationMap</a></li><li><a href="Gitana.InteractionCity.html">Gitana.InteractionCity</a></li><li><a href="Gitana.InteractionCityMap.html">Gitana.InteractionCityMap</a></li><li><a href="Gitana.InteractionContinent.html">Gitana.InteractionContinent</a></li><li><a href="Gitana.InteractionContinentMap.html">Gitana.InteractionContinentMap</a></li><li><a href="Gitana.InteractionCountry.html">Gitana.InteractionCountry</a></li><li><a href="Gitana.InteractionCountryMap.html">Gitana.InteractionCountryMap</a></li><li><a href="Gitana.InteractionDevice.html">Gitana.InteractionDevice</a></li><li><a href="Gitana.InteractionDeviceMap.html">Gitana.InteractionDeviceMap</a></li><li><a href="Gitana.InteractionMap.html">Gitana.InteractionMap</a></li><li><a href="Gitana.InteractionNode.html">Gitana.InteractionNode</a></li><li><a href="Gitana.InteractionNodeMap.html">Gitana.InteractionNodeMap</a></li><li><a href="Gitana.InteractionOperatingSystem.html">Gitana.InteractionOperatingSystem</a></li><li><a href="Gitana.InteractionOperatingSystemMap.html">Gitana.InteractionOperatingSystemMap</a></li><li><a href="Gitana.InteractionPage.html">Gitana.InteractionPage</a></li><li><a href="Gitana.InteractionPageMap.html">Gitana.InteractionPageMap</a></li><li><a href="Gitana.InteractionPostalCode.html">Gitana.InteractionPostalCode</a></li><li><a href="Gitana.InteractionPostalCodeMap.html">Gitana.InteractionPostalCodeMap</a></li><li><a href="Gitana.InteractionRegion.html">Gitana.InteractionRegion</a></li><li><a href="Gitana.InteractionRegionMap.html">Gitana.InteractionRegionMap</a></li><li><a href="Gitana.InteractionReport.html">Gitana.InteractionReport</a></li><li><a href="Gitana.InteractionReportEntry.html">Gitana.InteractionReportEntry</a></li><li><a href="Gitana.InteractionReportEntryMap.html">Gitana.InteractionReportEntryMap</a></li><li><a href="Gitana.InteractionReportMap.html">Gitana.InteractionReportMap</a></li><li><a href="Gitana.InteractionSession.html">Gitana.InteractionSession</a></li><li><a href="Gitana.InteractionSessionMap.html">Gitana.InteractionSessionMap</a></li><li><a href="Gitana.InteractionUser.html">Gitana.InteractionUser</a></li><li><a href="Gitana.InteractionUserAgent.html">Gitana.InteractionUserAgent</a></li><li><a href="Gitana.InteractionUserAgentMap.html">Gitana.InteractionUserAgentMap</a></li><li><a href="Gitana.InteractionUserMap.html">Gitana.InteractionUserMap</a></li><li><a href="Gitana.Job.html">Gitana.Job</a></li><li><a href="Gitana.JobMap.html">Gitana.JobMap</a></li><li><a href="Gitana.LogEntry.html">Gitana.LogEntry</a></li><li><a href="Gitana.LogEntryMap.html">Gitana.LogEntryMap</a></li><li><a href="Gitana.MergeConflict.html">Gitana.MergeConflict</a></li><li><a href="Gitana.MergeConflictMap.html">Gitana.MergeConflictMap</a></li><li><a href="Gitana.Message.html">Gitana.Message</a></li><li><a href="Gitana.MessageMap.html">Gitana.MessageMap</a></li><li><a href="Gitana.Meter.html">Gitana.Meter</a></li><li><a href="Gitana.MeterMap.html">Gitana.MeterMap</a></li><li><a href="Gitana.Node.html">Gitana.Node</a></li><li><a href="Gitana.NodeAttachment.html">Gitana.NodeAttachment</a></li><li><a href="Gitana.NodeAttachmentMap.html">Gitana.NodeAttachmentMap</a></li><li><a href="Gitana.NodeMap.html">Gitana.NodeMap</a></li><li><a href="Gitana.OAuth2Http.html">Gitana.OAuth2Http</a></li><li><a href="Gitana.OAuth2Http.Storage.html">Gitana.OAuth2Http.Storage</a></li><li><a href="Gitana.PageRendition.html">Gitana.PageRendition</a></li><li><a href="Gitana.PageRenditionMap.html">Gitana.PageRenditionMap</a></li><li><a href="Gitana.Person.html">Gitana.Person</a></li><li><a href="Gitana.Plan.html">Gitana.Plan</a></li><li><a href="Gitana.PlanMap.html">Gitana.PlanMap</a></li><li><a href="Gitana.Platform.html">Gitana.Platform</a></li><li><a href="Gitana.PlatformDataStoreMap.html">Gitana.PlatformDataStoreMap</a></li><li><a href="Gitana.PrincipalMap.html">Gitana.PrincipalMap</a></li><li><a href="Gitana.Project.html">Gitana.Project</a></li><li><a href="Gitana.ProjectMap.html">Gitana.ProjectMap</a></li><li><a href="Gitana.Registrar.html">Gitana.Registrar</a></li><li><a href="Gitana.RegistrarMap.html">Gitana.RegistrarMap</a></li><li><a href="Gitana.Registration.html">Gitana.Registration</a></li><li><a href="Gitana.RegistrationMap.html">Gitana.RegistrationMap</a></li><li><a href="Gitana.Release.html">Gitana.Release</a></li><li><a href="Gitana.ReleaseMap.html">Gitana.ReleaseMap</a></li><li><a href="Gitana.Report.html">Gitana.Report</a></li><li><a href="Gitana.ReportMap.html">Gitana.ReportMap</a></li><li><a href="Gitana.Repository.html">Gitana.Repository</a></li><li><a href="Gitana.RepositoryMap.html">Gitana.RepositoryMap</a></li><li><a href="Gitana.Response.html">Gitana.Response</a></li><li><a href="Gitana.Role.html">Gitana.Role</a></li><li><a href="Gitana.RoleMap.html">Gitana.RoleMap</a></li><li><a href="Gitana.ScheduledWork.html">Gitana.ScheduledWork</a></li><li><a href="Gitana.ScheduledWorkMap.html">Gitana.ScheduledWorkMap</a></li><li><a href="Gitana.Settings.html">Gitana.Settings</a></li><li><a href="Gitana.SettingsMap.html">Gitana.SettingsMap</a></li><li><a href="Gitana.Stack.html">Gitana.Stack</a></li><li><a href="Gitana.StackMap.html">Gitana.StackMap</a></li><li><a href="Gitana.SystemMetadata.html">Gitana.SystemMetadata</a></li><li><a href="Gitana.Team.html">Gitana.Team</a></li><li><a href="Gitana.TeamMap.html">Gitana.TeamMap</a></li><li><a href="Gitana.TeamMember.html">Gitana.TeamMember</a></li><li><a href="Gitana.TeamMemberMap.html">Gitana.TeamMemberMap</a></li><li><a href="Gitana.Tenant.html">Gitana.Tenant</a></li><li><a href="Gitana.TenantMap.html">Gitana.TenantMap</a></li><li><a href="Gitana.Timestamp.html">Gitana.Timestamp</a></li><li><a href="Gitana.TransferExportJob.html">Gitana.TransferExportJob</a></li><li><a href="Gitana.TransferImportJob.html">Gitana.TransferImportJob</a></li><li><a href="Gitana.TraversalResults.html">Gitana.TraversalResults</a></li><li><a href="Gitana.TrustedDomainMapping.html">Gitana.TrustedDomainMapping</a></li><li><a href="Gitana.TrustedDomainMappingMap.html">Gitana.TrustedDomainMappingMap</a></li><li><a href="Gitana.UIConfig.html">Gitana.UIConfig</a></li><li><a href="Gitana.UIConfigMap.html">Gitana.UIConfigMap</a></li><li><a href="Gitana.Vault.html">Gitana.Vault</a></li><li><a href="Gitana.VaultMap.html">Gitana.VaultMap</a></li><li><a href="Gitana.Warehouse.html">Gitana.Warehouse</a></li><li><a href="Gitana.WarehouseMap.html">Gitana.WarehouseMap</a></li><li><a href="Gitana.WebHost.html">Gitana.WebHost</a></li><li><a href="Gitana.WebHostMap.html">Gitana.WebHostMap</a></li><li><a href="Gitana.WorkflowComment.html">Gitana.WorkflowComment</a></li><li><a href="Gitana.WorkflowCommentMap.html">Gitana.WorkflowCommentMap</a></li><li><a href="Gitana.WorkflowInstance.html">Gitana.WorkflowInstance</a></li><li><a href="Gitana.WorkflowInstanceMap.html">Gitana.WorkflowInstanceMap</a></li><li><a href="Gitana.WorkflowModel.html">Gitana.WorkflowModel</a></li><li><a href="Gitana.WorkflowModelMap.html">Gitana.WorkflowModelMap</a></li><li><a href="Gitana.WorkflowTask.html">Gitana.WorkflowTask</a></li><li><a href="Gitana.WorkflowTaskMap.html">Gitana.WorkflowTaskMap</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: http/OAuth2Http.js</h1>
    
<section>
    <article>
        <pre
            class="sunlight-highlight-javascript linenums">(function(global)
{
    Gitana.OAuth2Http = Gitana.Http.extend(
    /** @lends Gitana.OAuth2Http.prototype */
    {
        /**
         * @constructs
         *
         * @class Gitana.OAuth2Http
         */
        constructor: function(options, storage)
        {
            var self = this;

            // storage for OAuth credentials
            // this can either be a string ("local", "session", "memory") or a storage instance or empty
            // if empty, memory-based storage is assumed
            if (storage === null || typeof(storage) === "string")
            {
                storage = new Gitana.OAuth2Http.Storage(storage);
            }

            // cookie mode
            this.cookieMode = null;

            // ticket mode
            this.ticketMode = null;

            // preset the error state
            this.error = null;
            this.errorDescription = null;
            this.errorUri = null;

            // gitana urls
            var tokenURL = "/oauth/token";
            if (options.tokenURL)
            {
                tokenURL = options.tokenURL;
            }

            // base URL?
            var baseURL = null;
            if (options.baseURL)
            {
                baseURL = options.baseURL;
            }

            // client
            var clientKey = options.clientKey;
            var clientSecret = options.clientSecret;

            // authorization flow
            // if none specified, assume CODE
            this.authorizationFlow = options.authorizationFlow || Gitana.OAuth2Http.AUTHORIZATION_CODE;

            // optional
            if (options.requestedScope)
            {
                this.requestedScope = options.requestedScope;
            }

            if (this.authorizationFlow == Gitana.OAuth2Http.AUTHORIZATION_CODE)
            {
                this.code = options.code;
                this.redirectUri = options.redirectUri;
            }

            if (this.authorizationFlow == Gitana.OAuth2Http.PASSWORD)
            {
                this.username = options.username;

                if (options.password)
                {
                    this.password = options.password;
                }
                else
                {
                    this.password = "";
                }
            }

            if (this.authorizationFlow == Gitana.OAuth2Http.COOKIE)
            {
                this.cookieMode = true;
            }

            if (this.authorizationFlow == Gitana.OAuth2Http.TICKET)
            {
                this.ticketMode = options.ticket;
            }

            this.ticketMaxAge = options.ticketMaxAge;


            ////////////////////////////////////////////////////////////////////////////////////////////////
            //
            // ACCESSORS
            //
            ////////////////////////////////////////////////////////////////////////////////////////////////

            /**
             * Clears persisted storage of auth data
             */
            this.clearStorage = function()
            {
                storage.clear();
            };

            /**
             * Gets or saves the access token
             *
             * @param value [String] optional value
             */
            this.accessToken = function(value)
            {
                return storage.poke("accessToken", value);
            };

            /**
             * Gets or saves the refresh token
             *
             * @param value [String] optional value
             */
            this.refreshToken = function(value)
            {
                return storage.poke("refreshToken", value);
            };

            /**
             * Gets or saves the granted scope
             *
             * @param value [String] optional value
             */
            this.grantedScope = function(value)
            {
                return storage.poke("grantedScope", value);
            };

            /**
             * Gets or saves the expires in value
             *
             * @param value [String] optional value
             */
            this.expiresIn = function(value)
            {
                return storage.poke("expiresIn", value);
            };

            /**
             * Gets or saves the grant time
             *
             * @param value [String] optional value
             */
            this.grantTime = function(value)
            {
                return storage.poke("grantTime", value);
            };

            this.getClientAuthorizationHeader = function() {

                var basicString = clientKey + ":";
                if (clientSecret)
                {
                    basicString += clientSecret;
                }
                return "Basic " + Gitana.btoa(basicString);
            };

            this.getBearerAuthorizationHeader = function()
            {
                return "Bearer " + self.accessToken();
            };

            this.getPrefixedTokenURL = function()
            {
                return this.getPrefixedURL(tokenURL);
            };

            this.getPrefixedURL = function(url)
            {
                var rebasedURL = url;
                if (baseURL &amp;&amp; Gitana.startsWith(url, "/"))
                {
                    rebasedURL = baseURL + url;
                }

                return rebasedURL;
            };


            // if they initiatialized with an access token, clear and write into persisted state
            // unless they're continuing an existing token
            if (this.authorizationFlow == Gitana.OAuth2Http.TOKEN)
            {
                var existingAccessToken = this.accessToken();
                if (existingAccessToken !== options.accessToken)
                {
                    storage.clear();
                }

                this.accessToken(existingAccessToken);
            }

            this.base();
        },

        /**
         * Performs an HTTP call using OAuth2.
         *
         * @param options
         */
        request: function(options)
        {
            var self = this;

            /**
             * Call over to Gitana and acquires an access token using flow authorization.
             *
             * @param success
             * @param failure
             */
            var doGetAccessToken = function(success, failure)
            {
                var onSuccess = function(response)
                {
                    var object = JSON.parse(response.text);
                    if (response["error"])
                    {
                        self.error = object["error"];
                        self.errorDescription = object["error_description"];
                        self.errorUri = object["error_uri"];
                    }
                    else
                    {
                        var _accessToken = object["access_token"];
                        var _refreshToken = object["refresh_token"];
                        var _expiresIn = object["expires_in"];
                        var _grantedScope = object["scope"];
                        var _grantTime = new Date().getTime();

                        // store into persistent storage
                        self.clearStorage();
                        self.accessToken(_accessToken);
                        self.refreshToken(_refreshToken);
                        self.expiresIn(_expiresIn);
                        self.grantedScope(_grantedScope);
                        self.grantTime(_grantTime);

                        // console.log("doGetAccessToken -> " + JSON.stringify(object));
                    }

                    success();
                };

                var onFailure = function(http, xhr) {
                    failure(http, xhr);
                };

                var o = {
                    success: onSuccess,
                    failure: onFailure,
                    headers: {
                        "Authorization": self.getClientAuthorizationHeader()
                    },
                    url: self.getPrefixedTokenURL(),
                    method: Gitana.OAuth2Http.TOKEN_METHOD
                };

                // query string
                var qs = {};

                // ticket max age
                if (self.ticketMaxAge)
                {
                    qs["ticketMaxAge"] = self.ticketMaxAge;
                }

                // if we're POSTing, do so as application/x-www-form-urlencoded to make secure over the wire
                if ("post" === Gitana.OAuth2Http.TOKEN_METHOD.toLowerCase())
                {
                    o.headers["Content-Type"] = "application/x-www-form-urlencoded";

                    // url encoded payload
                    var urlEncodedTokens = {};
                    urlEncodedTokens["grant_type"] = self.authorizationFlow;
                    if (self.requestedScope) {
                        urlEncodedTokens["scope"] = self.requestedScope;
                    }
                    if (self.authorizationFlow === Gitana.OAuth2Http.AUTHORIZATION_CODE)
                    {
                        urlEncodedTokens["code"] = self.code;
                        if (self.redirectUri) {
                            urlEncodedTokens["redirect_uri"] = self.redirectUri;
                        }
                    }
                    else if (self.authorizationFlow === Gitana.OAuth2Http.PASSWORD)
                    {
                        urlEncodedTokens["username"] = self.username;
                        urlEncodedTokens["password"] = self.password;
                    }
                    o.data = "" + Gitana.Http.toQueryString(urlEncodedTokens);
                }
                else
                {
                    qs["grant_type"] = self.authorizationFlow;
                    if (self.requestedScope) {
                        qs["scope"] = self.requestedScope;
                    }
                    if (self.authorizationFlow === Gitana.OAuth2Http.AUTHORIZATION_CODE)
                    {
                        qs["code"] = self.code;
                        if (self.redirectUri) {
                            qs["redirect_uri"] = self.redirectUri;
                        }
                    }
                    else if (self.authorizationFlow === Gitana.OAuth2Http.PASSWORD)
                    {
                        qs["username"] = self.username;
                        qs["password"] = self.password;
                    }
                }

                // append into query string
                var queryString = Gitana.Http.toQueryString(qs);
                if (queryString)
                {
                    if (o.url.indexOf("?") > -1)
                    {
                        o.url = o.url + "&amp;" + queryString;
                    }
                    else
                    {
                        o.url = o.url + "?" + queryString;
                    }
                }

                self.invoke(o);
            };

            if (typeof(Gitana.REFRESH_TOKEN_LOCKS) === "undefined")
            {
                Gitana.REFRESH_TOKEN_LOCKS = {};
            }
            if (typeof(Gitana.REFRESH_TOKEN_LOCK_REATTEMPT_MS) === "undefined")
            {
                Gitana.REFRESH_TOKEN_LOCK_REATTEMPT_MS = 75;
            }

            var waitForPendingRefresh = function(key, oldAccessToken)
            {
                setTimeout(function() {

                    // if another "thread" is still refreshing, keep on waiting
                    if (Gitana.REFRESH_TOKEN_LOCKS[key]) {
                        return waitForPendingRefresh();
                    }

                    // if we get this far, we take advantage of the new access key
                    // first check to make sure that it is a different access key
                    var newAccessToken = self.accessToken();

                    // we try the call again under the assumption that the access token is valid
                    // if the access token is different, we allow for another attempted refresh
                    // otherwise we do not to avoid spinning around forever
                    var autoAttemptRefresh = (newAccessToken === oldAccessToken);

                    // fire the call
                    doCall(autoAttemptRefresh);

                }, Gitana.REFRESH_TOKEN_LOCK_REATTEMPT_MS)
            };

            /**
             * Calls over to Gitana and acquires an access token using an existing refresh token.
             *
             * We use a refresh token lock here (scoped to the module) so that only one event loop per refresh token
             * is allowed to perform the refresh at a time.  This is to avoid making excessive network calls and also
             * helps to avoid race/bounce conditions when multiple refresh tokens come back, spinning things out of
             * control.  Eventually it settles down but better to avoid altogether.
             *
             * @param success
             * @param failure
             */
            var doRefreshAccessToken = function(success, failure) {

                var key = self.refreshToken();
                var oldAccessToken = self.accessToken();

                // if another "thread" is refreshing for this refresh key, then we wait until it finishes
                // when it finishes, we either use the acquired access token or make another attempt
                if (Gitana.REFRESH_TOKEN_LOCKS[key]) {
                    return waitForPendingRefresh(key, oldAccessToken);
                }

                // claim that we are the "thread" doing the refresh
                Gitana.REFRESH_TOKEN_LOCKS[key] = true;

                // make the http call for the refresh
                _doRefreshAccessToken(function(response) {

                    // all done, delete the lock
                    delete Gitana.REFRESH_TOKEN_LOCKS[key];

                    // callback
                    success(response);

                }, function(http, xhr) {

                    // didn't work, release the lock
                    delete Gitana.REFRESH_TOKEN_LOCKS[key];

                    // callback
                    failure(http, xhr);
                });
            };

            var _doRefreshAccessToken = function(success, failure) {

                var onSuccess = function(response)
                {
                    var object = JSON.parse(response.text);
                    if (response["error"])
                    {
                        self.error = object["error"];
                        self.errorDescription = object["error_description"];
                        self.errorUri = object["error_uri"];
                    }
                    else
                    {
                        var _accessToken = object["access_token"];
                        var _refreshToken = object["refresh_token"];
                        var _expiresIn = object["expires_in"];
                        //self.grantedScope = object["scope"]; // this doesn't come back on refresh, assumed the same
                        var _grantTime = new Date().getTime();
                        var _grantedScope = self.grantedScope();

                        // store into persistent storage
                        self.clearStorage();
                        self.accessToken(_accessToken);
                        self.refreshToken(_refreshToken);
                        self.expiresIn(_expiresIn);
                        self.grantedScope(_grantedScope);
                        self.grantTime(_grantTime);
                    }

                    success(response);
                };

                var onFailure = function(http, xhr) {

                    Gitana.REFRESH_TOKEN_FAILURE_FN(self, http, xhr);

                    failure(http, xhr);
                };

                var o = {
                    success: onSuccess,
                    failure: onFailure,
                    headers: {
                        "Authorization": self.getClientAuthorizationHeader()
                    },
                    url: self.getPrefixedTokenURL(),
                    method: Gitana.OAuth2Http.TOKEN_METHOD
                };

                // query string
                var qs = {};

                // ticket max age
                if (self.ticketMaxAge)
                {
                    qs["ticketMaxAge"] = self.ticketMaxAge;
                }

                // if we're POSTing, do so as application/x-www-form-urlencoded to make secure over the wire
                if ("post" === Gitana.OAuth2Http.TOKEN_METHOD.toLowerCase())
                {
                    o.headers["Content-Type"] = "application/x-www-form-urlencoded";

                    // url encoded payload
                    var urlEncodedTokens = {};
                    urlEncodedTokens["grant_type"] = "refresh_token";
                    urlEncodedTokens["refresh_token"] = self.refreshToken();
                    if (self.requestedScope)
                    {
                        urlEncodedTokens["scope"] = self.requestedScope;
                    }
                    o.data = "" + Gitana.Http.toQueryString(urlEncodedTokens);
                }
                else
                {
                    qs["grant_type"] = "refresh_token";
                    qs["refresh_token"] = self.refreshToken();
                    if (self.requestedScope)
                    {
                        qs["scope"] = self.requestedScope;
                    }
                }

                // append into query string
                var queryString = Gitana.Http.toQueryString(qs);
                if (queryString)
                {
                    if (o.url.indexOf("?") > -1)
                    {
                        o.url = o.url + "&amp;" + queryString;
                    }
                    else
                    {
                        o.url = o.url + "?" + queryString;
                    }
                }

                self.invoke(o);
            };

            var doCall = function(autoAttemptRefresh)
            {
                var successHandler = function(response)
                {
                    options.success(response);
                };

                var failureHandler = function(http, xhr)
                {
                    if (autoAttemptRefresh)
                    {
                        // there are a few good reasons why this might naturally fail
                        //
                        // 1.  our access token is invalid, has expired or has been forcefully invalidated on the Cloud CMS server
                        //     in this case, we get back a 200 and something like http.text =
                        //     {"error":"invalid_token","error_description":"Invalid access token: blahblahblah"}
                        //
                        // 2.  the access token no longer permits access to the resource
                        //     in this case, we get back a 401
                        //     it might not make much sense to re-request a new access token, but we do just in case.

                        var notJson = false;
                        var isInvalidToken = false;
                        if (http.text)
                        {
                            var responseData = {};

                            // catch if http.text is not JSON
                            try
                            {
                                responseData = JSON.parse(http.text);
                            }
                            catch (e)
                            {
                                console.log("Error response is not json");
                                console.log(e);
                                console.log(http.text);
                                notJson = true;
                            }

                            if (responseData.error)
                            {
                                if (responseData.error == "invalid_token")
                                {
                                    isInvalidToken = true;
                                }
                            }
                        }
                        var is401 = (http.code == 401);
                        var is400 = (http.code == 400);
                        var is403 = (http.code == 403);
                        var isTimeout = http.timeout;

                        // handle both cases
                        if (is401 || is400 || is403 || isInvalidToken || (notJson &amp;&amp; !isTimeout))
                        {
                            if (self.refreshToken())
                            {
                                // use the refresh token to acquire a new access token
                                doRefreshAccessToken(function() {

                                    // success, got a new access token

                                    doCall(false);

                                }, function() {

                                    // failure, nothing else we can do
                                    // call into intended failure handler with the original failure http object
                                    options.failure(http, xhr);
                                });
                            }
                            else
                            {
                                // fail case - nothing we can do
                                options.failure(http, xhr);
                            }
                        }
                        else
                        {
                            // some other kind of error
                            options.failure(http, xhr);
                        }
                    }
                    else
                    {
                        // we aren't allowed to automatically attempt to get a new token via refresh token
                        options.failure(http, xhr);
                    }
                };

                // call through to the protected resource (with custom success/failure handling)
                var o = {};
                Gitana.copyInto(o, options);
                o.success = successHandler;
                o.failure = failureHandler;
                if (!o.headers)
                {
                    o.headers = {};
                }
                if (!self.cookieMode &amp;&amp; !self.ticketMode)
                {
                    o.headers["Authorization"] = self.getBearerAuthorizationHeader();
                }
                if (self.ticketMode)
                {
                    o.headers["GITANA_TICKET"] = encodeURIComponent(self.ticketMode);
                }
                o.url = self.getPrefixedURL(o.url);

                // make the call
                self.invoke(o);
            };

            // if we have an access token and it's about to expire (within 20 seconds of it's expiry),
            // we force an early refresh of the access token so that concurrent requests don't get access problems
            // this is important for any browser-originated requests that rely on a persisted cookie (GITANA_TICKET)
            //
            // also provide some debugging if needed
            var forceRefresh = false;
            if (self.accessToken())
            {
                var grantTime = self.grantTime();
                if (grantTime)
                {
                    var expiresIn = self.expiresIn();
                    if (expiresIn)
                    {
                        // NOTE: expiresIn is in seconds
                        var expirationTimeMs = self.grantTime() + (self.expiresIn() * 1000);
                        var nowTimeMs = new Date().getTime();

                        var timeRemainingMs = expirationTimeMs - nowTimeMs;
                        if (timeRemainingMs &lt;= 0)
                        {
                            // console.log("Access Token is expired, refresh will be attempted!");
                        }
                        else
                        {
                            // console.log("Access Token Time Remaining: " + timeRemainingMs);
                        }

                        if (timeRemainingMs &lt;= 20000)
                        {
                            // console.log("Access Token only has 20 seconds left, forcing early refresh");
                            forceRefresh = true;
                        }
                    }
                }
            }

            // if no access token, request one
            if ((!self.accessToken() || forceRefresh) &amp;&amp; !this.cookieMode &amp;&amp; !this.ticketMode)
            {
                if (!self.refreshToken())
                {
                    // no refresh token, do an authorization call
                    doGetAccessToken(function() {

                        // got an access token, so proceed
                        doCall(true);

                    }, function(http, xhr) {

                        // access denied
                        options.failure(http, xhr);

                    });
                }
                else
                {
                    // we have a refresh token, so do a refresh call
                    doRefreshAccessToken(function() {

                        // got an access token, so proceed
                        doCall(true);

                    }, function(http, xhr) {

                        // unable to get an access token
                        options.failure(http, xhr);

                    });
                }
            }
            else
            {
                // we already have an access token
                doCall(true);
            }
        },

        /**
         * Refreshes the OAuth2 access token.
         */
        refresh: function(callback)
        {
            var self = this;

            var onSuccess = function(response)
            {
                var object = JSON.parse(response.text);
                if (response["error"])
                {
                    self.error = object["error"];
                    self.errorDescription = object["error_description"];
                    self.errorUri = object["error_uri"];

                    callback({
                        "error": self.error,
                        "message": self.errorDescription
                    });
                }
                else
                {
                    var _accessToken = object["access_token"];
                    var _refreshToken = object["refresh_token"];
                    var _expiresIn = object["expires_in"];
                    //self.grantedScope = object["scope"]; // this doesn't come back on refresh, assumed the same
                    var _grantTime = new Date().getTime();
                    var _grantedScope = self.grantedScope();

                    // store into persistent storage
                    self.clearStorage();
                    self.accessToken(_accessToken);
                    self.refreshToken(_refreshToken);
                    self.expiresIn(_expiresIn);
                    self.grantedScope(_grantedScope);
                    self.grantTime(_grantTime);

                    callback();
                }
            };

            var onFailure = function(http, xhr)
            {
                Gitana.REFRESH_TOKEN_FAILURE_FN(self, http, xhr);

                callback({
                    "message": "Unable to refresh access token"
                });
            };

            var o = {
                success: onSuccess,
                failure: onFailure,
                headers: {
                    "Authorization": self.getClientAuthorizationHeader()
                },
                url: self.getPrefixedTokenURL(),
                method: Gitana.OAuth2Http.TOKEN_METHOD
            };

            // query string
            var qs = {};

            // ticket max age
            if (self.ticketMaxAge)
            {
                qs["ticketMaxAge"] = self.ticketMaxAge;
            }

            // if we're POSTing, do so as application/x-www-form-urlencoded to make secure over the wire
            if ("post" === Gitana.OAuth2Http.TOKEN_METHOD.toLowerCase())
            {
                o.headers["Content-Type"] = "application/x-www-form-urlencoded";

                // url encoded data
                var urlEncodedTokens = {};
                urlEncodedTokens["grant_type"] = "refresh_token";
                urlEncodedTokens["refresh_token"] = self.refreshToken();
                if (self.requestedScope)
                {
                    urlEncodedTokens["scope"] = self.requestedScope;
                }
                o.data = "" + Gitana.Http.toQueryString(urlEncodedTokens);
            }
            else
            {
                qs["grant_type"] = "refresh_token";
                qs["refresh_token"] = self.refreshToken();
                if (self.requestedScope)
                {
                    qs["scope"] = self.requestedScope;
                }
            }

            // append into query string
            var queryString = Gitana.Http.toQueryString(qs);
            if (queryString)
            {
                if (o.url.indexOf("?") > -1)
                {
                    o.url = o.url + "&amp;" + queryString;
                }
                else
                {
                    o.url = o.url + "?" + queryString;
                }
            }

            self.invoke(o);
        }
    });

    /**
     * Provides a storage location for OAuth2 credentials
     *
     * @param scope
     *
     * @return storage instance
     * @constructor
     */
    Gitana.OAuth2Http.Storage = function(scope)
    {
        // in-memory implementation of HTML5 storage interface
        var memoryStorage = function() {

            var memory = {};

            var m = {};
            m.removeItem = function(key)
            {
                delete memory[key];
            };

            m.getItem = function(key)
            {
                return memory[key];
            };

            m.setItem = function(key, value)
            {
                memory[key] = value;
            };

            return m;
        }();

        /**
         * Determines whether the current runtime environment supports HTML5 local storage
         *
         * @return {Boolean}
         */
        var supportsLocalStorage = function()
        {
            try {
                return 'localStorage' in window &amp;&amp; window['localStorage'] !== null;
            } catch (e) {
                return false;
            }
        };

        /**
         * Determines whether the current runtime environment supports HTML5 session storage.
         *
         * @return {Boolean}
         */
        var supportsSessionStorage = function()
        {
            try {
                return 'sessionStorage' in window &amp;&amp; window['sessionStorage'] !== null;
            } catch (e) {
                return false;
            }
        };

        var acquireStorage = function()
        {
            var storage = null;

            // store
            if (scope == "session" &amp;&amp; supportsSessionStorage())
            {
                storage = sessionStorage;
            }
            else if (scope == "local" &amp;&amp; supportsLocalStorage())
            {
                storage = localStorage;
            }
            else
            {
                // fall back to memory-based storage
                storage = memoryStorage;
            }

            return storage;
        };

        // result object
        var r = {};

        /**
         * Clears state.
         */
        r.clear = function()
        {
            // we first set to empty to account for a bug in Chrome
            // this bug is with the removeItem method where it sometimes doesn't work, so force to empty to handle worst case
            // https://bugs.chromium.org/p/chromium/issues/detail?id=765524
            acquireStorage().setItem("gitanaAuthState", "");

            // now do the actual remove
            acquireStorage().removeItem("gitanaAuthState");
        };

        /**
         * Pokes and peeks the value of a key in the state.
         *
         * @param key
         * @param value
         *
         * @return {*}
         */
        r.poke = function(key, value)
        {
            var state = {};

            var stateString = acquireStorage().getItem("gitanaAuthState");
            if (stateString &amp;&amp; stateString !== "") {
                state = JSON.parse(stateString);
            }

            var touch = false;
            if (typeof(value) !== "undefined" &amp;&amp; value !== null)
            {
                state[key] = value;
                touch = true;
            }
            else if (value === null)
            {
                delete state[key];
                touch = true;
            }

            if (touch) {
                acquireStorage().setItem("gitanaAuthState", JSON.stringify(state));
            }

            return state[key];
        };

        return r;
    };

}(this));

// statics
Gitana.OAuth2Http.PASSWORD = "password";
Gitana.OAuth2Http.AUTHORIZATION_CODE = "authorization_code";
Gitana.OAuth2Http.TOKEN = "token";
Gitana.OAuth2Http.COOKIE = "cookie";
Gitana.OAuth2Http.TICKET = "ticket";

// method to use for retrieving access and refresh tokens
//Gitana.OAuth2Http.TOKEN_METHOD = "GET";
Gitana.OAuth2Http.TOKEN_METHOD = "POST";



</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


	<span class="copyright">
	Copyright © 2016 Gitana Software, Inc.
	</span>

<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a>
	
		on Mon Aug 6th 2018
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>
